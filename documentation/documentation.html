<!DOCTYPE html>
<html lang="he"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <title>Weight Track</title>
	<style>
	@import "https://fonts.googleapis.com/css?family=Alef:400,700&subset=hebrew";

body {
    direction: rtl;
    font-family: Alef, sans-serif;
    background-color: #cc99ff;
    font-size: 24px;
    color: #173e43;
    margin: 0;
    padding-top: 80px; 
}

header {
	position: fixed;
	background: white;
	height: 80px;
	padding: 0 15px;
	width: 100%;
	top: 0;
}
header a{
	display: inline-block;
	vertical-align: bottom;
	box-sizing: border-box;
	color: black;
	text-decoration: none;
	margin-left: 20px;
	padding-bottom: -20px;
}


header a:hover{
	text-decoration: underline;
}


#logoContainer{
	height: 65px;
}

h1 {
    font-size: 2.25em;
    text-align: center;
}


img.resize {
  max-height:270px;
  display: block;
    margin: auto;
	margin-bottom: 25px;
	margin-top: 25px;
	border-width:5px;  
    border-style:ridge;
	border-color: #e6ccff
}

img.tarshim {

  display: block;
    margin: auto;
	margin-bottom: 25px;
	margin-top: 25px;
}

h2 {
    font-size: 2em;
    margin-bottom: 25px;
	padding-top: 80px;
    margin-top: -80px;
}

h3 {
	padding-top: 80px;  
}

main {
    max-width: 1024px;
    margin: auto;
    background-color: rgba(255, 255, 255, 0.7);
    padding: 20px 110px 20px 60px;
    box-sizing: border-box;
}

p {
    text-align: justify;
}



span.highlight {
    font-weight: bold;
}
span.com {
	color: red;
    font-weight:bold;
    font-style:italic;
}

section {
    border-right: 5px solid #a5cae9;
    padding-right: 30px;
    margin-bottom: 60px;
}

code {
	font-family: monospace;
	font-size: 20px;
}


	</style>
</head>
<body>
<header>
    
    <a href="#L1">
        המוצר ושימושיו
    </a>
    <a href="#L2">
        חומרה
    </a>
    <a href="#L3">
        Raspberry Pie
    </a>
	<a href="#L4">
		האפליקציה
	</a>
	<a href="#L5">
		אתגרים ודרכי פתרון
	</a>
</header>
<main>

    <article>
        <section style="font-family:sans-serif">
            בר אנג'ל 307901587 bar.ang16@gmail.com<br />
            רון אלטבוים 039563838 ron018@gmail.com<br />
            רמי לרנר 038053294 ramylern@mail.tau.ac.il<br />
        </section>
        <section>
            <h2 id="L1">
                המוצר ושימושיו
            </h2>
            <figure>
              
            </figure>
            <p>

				Weight Track הוא משקל דיגיטלי חכם ושם האפליקציה הסלולרית הנלווית אליו. בכל פעם שהמשתמש עולה להשקל, נתוני השקילה נשמרים בבסיס נתונים בענן.  האפליקציה מספקת ממשק נוח ואינטראקטיבי המאפשר למשתמש לקבל לא רק את תוצאת השקילה אלא גם סטטיסטיקות נוספות הקשורות בשקילות קודמות ותצוגות מתקדמות באמצעות גרפים. המכשיר מיועד בעיקר לשימוש ביתי. הוא מועיל במיוחד לספורטאים, שומרי משקל, מטופלים תחת מעקב רפואי או  לכל החפץ לנהל מעקב מדוייק אחר השינויים במשקלו. בנוסף מתאים המכשיר גם לשימושים עסקיים וציבוריים כמו חדרי כושר, קופות חולים, קניונים, מסלולי הליכה עירוניים וכו'.
            </p>
            <p>
                Weight Track מצוייד במכשיר Raspberry Pie (להלן RPI). בשימוש הראשון יש להתקין את ה-RPI. לאחר מכן ניתן להתחיל להשקל. לפני כל שקילה יש לסרוק באמצעות האפליקציה את קוד ה-QR המצורף למכשיר ה-Weight Track ולאחר מכן לעלות על המשקל ולהשקל כרגיל.
            </p>
        </section>
        <section>
            <h2 id="L2">
                סרטון הדגמה
            </h2>
            <p>
                <iframe src="http://www.youtube.com/embed/nIXf4Y82xXs"
                        width="560" height="315" frameborder="0" allowfullscreen></iframe> 
                <br/>
                הסרטון לא עובד? לחץ <a href="http://www.youtube.com/embed/nIXf4Y82xXs">כאן</a>
                
            </p>
        </section>
        <section>
            <h2 id="L2">
                חומרה
            </h2>
			
			<ul>
				<li>
					<h4>Raspberry Pie 2</h4>
					<img class="resize" src="images/rasp2.jpg">
				</li>
				<li>
					<a href="https://www.sparkfun.com/products/13879">SparkFun Load Cell Amplifier - HX711</a>
					<img class="resize" src="images/hx711.jpg">
				</li>
				<li>
					<a href="https://www.sparkfun.com/products/13878">SparkFun Load Sensor Combinator</a>
					<img class="resize" src="images/combinator.jpg">
				</li>
				<li>
					<h4>משקל דיגיטלי ביתי</h4>
				</li>

			</ul>
			
			<h3>הרכבת החומרה</h3>
			<p>לקחנו משקל דיגיטלי ביתי ונתקנו ממנו את המעגל החשמלי שלו. במשקל ישנם ארבעה חיישני משקל מסוג Load Cell, ולכל אחד מהם שלושה חוטים (אדום, שחור, לבן) המחוברים למעגל החשמלי. להלן תרשים של החיישן:</p>
				<img class="resize" src="images/wires.png">
			<p>
				מכיוון שלא קיימת סטנדרטיזציה לצבע החוטים, השתמשנו במולטימטר על מנת למדוד את ההתנגדות בין כל זוג חוטים. היה עלינו למצוא את הזוג בעל ההתנגדות הגבוהה ביותר. במשקל שלנו ההתנגדות הגבוהה ביותר נמצאה בין החוט הלבן לשחור. נעזרנו במנחה הסדנה על מנת להלחים את החוטים אל ה-Combinator באופן הבא: החוטים השחורים למינוס (-), הלבנים לפלוס (+) והאדומים למרכז (C):
			</p>
			<img class="resize" src="images/combinator_up.jpg">
			<p>
				אחת הדרכים לקחת שינויי התנגדות קטנים ולהופכם למשהו מדיד היא שימוש ב-
				<a href="https://en.wikipedia.org/wiki/Wheatstone_bridge">Wheatstone bridge</a>
				. זוהי תצורה של ארבעה נגדים ומתח קבוע מראש, כמתואר בתרשים:
			</p>
			<img class="resize" src="images/bridge.gif">
			<p>
				ה-Combinator מחבר יחדיו את ארבעת החיישנים באופן כזה ששני נגדים בתצורת ה-wheatstone bridge הינם קבועים, והשניים האחרים משתנים.
			</p>
			<p>
				לאחר הלחמת תריסר החוטים אל ה-Combinator חברנו אותו אל הלוח של מגבר ה-HX711 דרך ארבעת החוטים הסטנדרטיים של Load Cell.
			</p>
			<p>
				לבסוף חיברנו את ה-RPI למגבר דרך יציאות GPIO.
			</p>
			           
        </section>
        <section>
            <h2 id="L3">
                Raspberry Pie
            </h2>
			<img class="tarshim" src="images/chart.png">
			<h3>
				התוכנית אשר רצה על ה-Raspberry Pie
			</h3>
				<p>
					התוכנית אשר רצה על ה-RPI בנויה בטכנולוגית Windows Universal Platform ונבנתה באמצעות Visual Studio 2017.
				</p>
				<p>
					התוכנית בנויה במבנה הדומה במידה רבה לשרת אינטרנט, כלומר התוכנית מאזינה באופן קבוע לבקשות התחברות מצד הלקוחות. כאשר מתקבלת בקשה, התוכנית מספקת את שירותה, שולחת חיווי ללקוח ואז סוגרת את החיבור.
				</p>
				<p>
					התוכנית ממשת ארבע פונקציות עיקריות כממפורט להלן:
				</p>
			<h3>
				התממשקות לחומרה
			</h3>
            <p>
                קריאת הנתונים מהסנסור נעשית על ידי מחלקה שכתבתנו בשפת C# ושמה LinearHX. זהו למעשה תרגום שביצענו עבור מחלקה שנכתבה עבור אנדרואיד בשפת C++: <a href="https://github.com/bogde/HX711">לעיון בקוד לחץ כאן.</a>
            </p>
            <p>
                מעבר לתרגום הקוד הנ"ל כך שיתאים ל-RPI, הוספנו בו מספר פונקציות אשר מממשות את תהליך הכיול של המשקל בצורה קלה ונוחה יותר לשימוש עבור הצרכים שלנו.
            </p>
				<p>
                    כמו כן כתבנו מחלקה נוספת בשם UserHardwareLinker אשר יורשת מ-LinearHX ומוסיפה לה פונקציות נוספות המאפשרות מעקב אחר המשתמשים, ויכולת זיהוי בכל עת האם המשקל נמצא בשימוש, ולהחזיר את פרטי המשתמשים אשר משתמשים במשקל.
				</p>
				
				<p>
					משך השקילה עורך כ-5 שניות. במהלכה הסנסור מבצע את השקילה מספר רב של פעמים (כאלף פעמים) ומחזיר את ממוצע השקילות שבוצעו. באופן זה אנו ממזערים את אי-דיוקים של הסנסור.
				</p>
				
			<h3>
				התחברות לענן Microsoft Azure – 
			</h3>
				<p>
					ההתחברות לענן נעשית בעזרת IoT Hub. רכיב זה נמצא בענן ומאזין להודעות אשר אשר נשלחות מהתוכנית אל הענן.
				</p>
				<p>
					התוכנית שולחת הודעה לענן  בשתי סיטואציות:
				</p>
				<ul>
					<li>רישום המכשיר לענן, או עדכון כתובתו </li>
					<li>שליחת הנתונים שהתקבלו ממד-המשקל יחד עם של המשתמש אשר ביצע את השקילה ותאריך השקילה</li>
				</ul>
			<h3>
				האזנה לבקשות התחברות 
			</h3>
				<p>
					כאשר משתמש רוצה לבצע שקילה עליו להודיע לתוכנית כי ברצונו להישקל. כאשר התוכנית מקבלת את ההודעה, היא יכולה לפנות לממשק ה-uhl לשם קבלת הנתונים מהסנסור.
				</p>
				<p>
					שליחת ההודעות נעשית באמצעות פרוטוקול אשר פותח על ידנו בשם Data Request Protocol (או בראשי-תיבות DRP). DRP הינו פרוטוקול תקשורת אשר יושב מעל פרוטוקול TCP הסטנדרטי. יצירת החיבור בין האפליקציה אצל הלקוח ומכשיר ה-RPI ממושת באמצעות Socket. התוכנית מקימה שרת בסיסי אשר מאזין להודעות DRP ומשרת אותן. <a href="#DRP">לחץ כאן להסבר מפורט על הפרוטוקול.</a>
				</p>
				
			<h3>
				תחזוקת הגדרות בסיסיות, ואספקת ממשק נוח המאפשר גישה להגדרות אלו
			</h3>
				<p>
					על הלקוח לספק למכשיר מספר הגדרות ראשונית בסיסיות, כלומר הגדרות שיש להגדירן באופן חד פעמי לפני השימוש במכשיר פעם הראשונה. אי-לכך יצרנו ממשק נוח המפאשר למשתמש גישה להגדרות המכשיר ולשינויים. ההגדרות נשמרות על כרטיס ה-SSD של ה-RPI, ולכן אינן משתנות גם לאחר כיבוי והפעלה מחדש של המכשיר.
				</p>
				<p>
					הנתונים שנשמרים הינם:
				</p>
				<ul>
					<li>שם מד-המשקל (ניתנת למשתמש האפשרות לתת למכשיר שברשותו שם אשר יוצג למשתמשים הנשקלים. זה יכול להיות נוח עבור משתמשים עסקיים)</li>
					<li>המספר הסידורי של המשקל</li>
					<li>כתובת ה-IP של המשקל כפי שנצפתה לאחרונה</li>
					<li>נתוני הכיול של המשקל*</li>
				</ul>
				<p>
					הגישה לנתונים אלו נעשית באמצעות ממשק WEB ולכן יכולה להתבצע מכל דפדפן סטנדרטי. המכשיר מתחזק שרת HTTP פשוט אשר מאזין לפורט 9000, ושולח את דף ההגדרות לכל לקוח אשר מנסה לגשת להגדרות המכשיר. הגישה להגדרות מתבצעת ע"י הזנת כתובת ה IP של המכשיר והפורט 9000 בשורת הכתובת של הדפדפן בעודו רץ ו"לגלוש" לדף שבו ניתן לכוון את הגדרות אלו.
				</p>
            <p>
                <sub> *המשקל מתבצע על ידי שקילת שני עצמים שמשקלם ידוע מראש, ואחד מעצמים אלה הוא בעל משקל 0 (כלומר שאין דבר על המשקל). על המתקין לספק את משקלו של עצם כלשהו ולאחר מכן לבצע שתי שקילות. המערכת תעבד את נתוני השקילות ותשמור את הערכים המתאימים למשכל המכויל </sub>
            </p>
				
			
        </section>
        <section>
            <h2 id="L4">
                האפליקציה
            </h2>
            <p>
                בפרוייקט זה הפכנו משקל-אמבטיה רגיל למשקל המחובר לאינטרנט. שקילות המשתמש מאוחסנות בענן של Azure בתוך מסד נתונים אשר יושב על שרת SQL. זה מאפשר למשתמש לעקוב אחר הסטוריית השקילות שלו מכל מכשיר Weight Track.

            </p>
			<p>
                 לשימוש בבית. כל שעל המשתמש לעשות הוא להוריד את אפליקציית Weight Track לאנדרואיד, מה שיאפשר לו להשתמש בכל מכשיר Weight Track שירצה!
			</p>
			<h3 id="dataFlowTarshim">מעבר הנתונים:</h3>
				<img class="tarshim" src="images/flow.png">
				<p>
					האפליקציה הינה אפליקציית Xamarin.Android אשר משתמשת בשירותי Azure כגון מסד נתונים SQL, IoTHub, StreamAnalytics ואימות באמצעות הפייסבוק. צד השרת הוא קוד javascript ומנוהל על ידי Azure. כתובת ה-URL של צד השרת:
				</p>
				<a href="http://iotweight.azurewebsites.net/">http://iotweight.azurewebsites.net</a>
				<p>
					צד הלקוח הוא תוכנית Xamarin.Android  (C#)
				</p>
			<h3>פרופיל משתמש</h3>
				<p>
					התחברות המשתמש לאפליקציה נעשית דרך הפייסבוק. בפעם הראשונה בה המשתמש מתחבר לאפליקציה, מוצג לפניו מסך התחברות דרך הפייסבוק, ועליו להזין את כתובת הדואר האלקטרוני והסיסמה איתם הוא רשום לפייסבוק. אז נוצר לו מספר זהות ייחודי ע"י ה-Azure המבוסס על כתובת המייל שהזין. מספר הזהות הזה מתאחסן במסד מידע SQL שבענן, ומשמש לזיהוי ייחודי של המשתמש. על ידי ביצוע תהליך האימות דרך פייסבוק אנו נמנעים מלאחסן כתובות דואר אלקטרוני וסיסמאות במסד המידע שלנו. לכן המימוש הזה בטוח יותר מזה האלטרנטיבי (כפי שמוסבר בספר המקוון
					<a href="https://adrianhall.github.io/develop-mobile-apps-with-csharp-and-azure/chapter2/custom/">הזה</a>
					שנכתב בידי מפתח מייקרוסופט.)
				</p>
				<p>
					המשתמש יכול להוסיף להוסיף לפרופיל שלו גם נתון גובה, ואז יוכל להשתמש במחשבון ה-BMI שבאפליקציה (הסבר מפורט בהמשך).
				</p>
				<p>הפרופילים של המשתמשים מאוחסנים בטבלת SQL הנקראת <code>UsersTable</code>, המכילה את השדות הבאים:</p>
				<ul>
					<li><code>string UniqueUsername</code> - זהו מספר הזהות הייחודי</li>
					<li><code>float height</code> - אופציונאלי</li>
				</ul>
			<h3 id="startWeight">מהלך השקילה</h3>
				<p>
					כאשר המשתמש רוצה לשקול את עצמו הוא לוחץ על כפתור Start Weight. לאחר מכן עליו לסרוק את הברקוד המצורף ל-RPI. לאחר שהאפליקציה סרקה את הברקוד, היא שולחת שאילתה לטבלת ה-SQL שבענן הנקראת <code>RaspberryTable</code>. בטבלה מצויים השדות הבאים:
				</p>
				<ul>
					<li><code>string QRCode</code> - הברקוד שעל ה-RPI</li>
					<li><code>string IPAddress</code> - כתובת ה-IP של ה-RPI</li>
				</ul>
				<p>
					השאילתה מחזירה את כתובת ה-IP של ה-RPI (התוכנית שרצה על ה-RPI כבר העלתה את המידע הזה לטבלה ודואגת שישאר עדכני).
				</p>
				<p>
					כעת, אפליקציית האנדרואיד שולחת לכתובת ה-IP הזאת הודעה בפורמט של הפרוטוקול DRP שהמצאנו. בהודעה זו היא מיידעת את ה-RPI שהמשתמש מעוניין להשקל, ושולחת ל-RPI את המספר הסידורי הייחודי של המשתמש. כך יודע ה-RPI מי המשתמש שרוצה להשקל. לאחר שהמשתמש נשקל, ה-RPI שולח הודעת DRP לאפליקציה ובה הוא מעביר לה את תוצאת השקילה. תוצאת השקילה מוצגת במסך המשתמש באפליקציה. בנוסף, האפליקציה שולחת הודעה ל-IoT Hub. ההודעה מכילה את המספר הסידורי הייחודי של המשתמש, תוצאת השקילה ואת תאריך השקילה. ההודעה מועברת מה-IoT Hub לטבלת SQL הנקראת <code>weighTable</code> דרך ה-Stream Analytics של Azure. הטבלה מכילה את השדות הבאים:
				</p>
				<ul>
					<li><code>string username</code> - מספרו הסידורי הייחודי של המשתמש</li>
					<li><code>float weight</code> - תוצאת השקילה</li>
					<li><code>DateTime createdAt</code> - תאריך השקילה</li>
				</ul>
			<h3>היסטוריית שקילות</h3>
				<p>
					המשתמש יכול לעיין בהסטוריית השקילות שלו על ידי לחיצה על כפתור Weight History באפליקציה. הוא יכול לבחור את פורמט התצוגה (גרף או רשימה) ואת משך הזמן: החודש האחרון, שלושת החודשים האחרונים, ששת החודשים האחרונים או להזין את משך הזמן בעצמו. האפליקציה מאחזרת את השקילות הקודמות באמצעות שאילתת SQL לטבלת <code>weighTable</code> שהוזכרה מקודם.
				</p>
			<h3>חישוב BMI</h3>
				<p>
					המשתמש יכול לגלות את מדד מסת הגוף (BMI) שלו בהתבסס על שקילתו האחרונה ע"י לחיצה על כפתור Calculate BMI באפלקיצה. בפעם הראשונה שבה המשתמש מחשב את ה-BMI שלו, הוא יידרש להזין את גובהו. נתון הגובה של המשתמש מועבר לטבלת ה-SQL <code>UsersTable</code> שהוזכרה מקודם ונשמרת שם. בפעמים הבאות בהן ירצה המשתמש לחשב את ה-BMI שלו, הוא לא לא יתבקש להזין את גובהו, והנתון יאוחזר מטבלת ה-SQL.
				</p>
				<p>
					בנוסף ל-BMI, האפליקציה מיידעת את המשתמש לאיזו קטגוריית BMI הוא שייך, כשהנורמה נעה בין 18.5 ל-25. כמו כן היא מציעה קישורית לעמוד ויקיפדיה שמכיל עוד מידע אודות קטגוריות BMI.
				</p>
			<h3 id="DRP">פרוטוקול DRP</h3>
				<p>
					DRP, או Data Request Protocol, הוא הפרוטוקול המשמש לתקשורת בין אפליקציית האנדרואיד ל-RPI (ישנן סוגי תקשורת נוספים ביניהם כגון IoT Hub,  כמתואר <a href="#startWeight">Start Weight</a> באפליקציה.  
				</p>
				<p>					
					הפרוטוקול מבוסס על מבנה JSON ואלו הם השדות שלו:
				</p>
				<ul>
					<li><strong>Protocol</strong> - שם הפרוטוקול. יכיל תמיד את אותה המחרוזת "$DRP" כדי להבדיל את ההודעה מהודעות לא רלוונטיות שעלולות "להתעופף" בענן.</li>
					<li><strong>DevType</strong> - יכיל את אחת המחרוזות APP או RBPI. האפליקציה תשלח הודעות מסוג APP וה-RPI ישלח הודעות מסוג RBPI.</li>
					<li><strong>SourceID</strong> - המספר הסידורי של שולח ההודעה.</li>
					<li><strong>IDDest</strong> - המספר הסידורי של נמען ההודעה.</li>
					<li><strong>Username</strong> - שם המשתמש שרוצה להישקל.</li>
					<li><strong>Data</strong> - מכיל את תוצאת השקילה.</li>
					<li><strong>Status</strong> - שדה זה מכיל את סוג ההודעה. המכשיר המקבל את ההודעה צריך לדעת כיצד להתייחס לשדות של הפרוטוקול בהתאם לסוג ההודעה. סוגי ההודעה האפשריים הם:
							<ul>
								<li><i>scanned</i> - מיד לאחר סריקת הקוד האפליקציה ל-RPI הודעה עם הסטטוס הזה ("הרגע סרקתי אותך"). ההודעה תכיל את שם המשתמש המחובר לאפליקציה.</li>
								<li><i>data</i> - מעביר מידע לאפליקציה (בשדה data) בלי לסגור את החיבור.</li>
								<li><i>ack</i> - בכל פעם שה-RPI/אפליקציה מקבל הודעה (עם סטטוס שונה מ-ACK) הוא יענה בהודעת ACK. בהודעת ACK חשוב שימצאו המספרים הסידוריים (שאר השדות יכולים להכיל זבל).</li>
								<li><i>InUse</i> - לא ניתן להישקל היות והמשקל נמצא בשימוש ע"י משתמש אחר.</li>
								<li><i>HardwareError</i> - לא ניתן להישקל בעקבות בעיות בחומרה.</li>
								<li><i>Illegal</i> - הודעה לא חוקית או הודעה שאינה ממקור אמין.</li>
							</ul>
					</li>
					<li><strong>Date</strong> - תאריך ושעת שליחת ההודעה.</li>
					
				</ul>	
        </section>
		<section>
			<h2 id="L5">אתגרים ודרכי פתרון</h2>
			<p>
				רוב האתגרים היו בהתחלה.  אתגר גדול היה בבחירת הפרוייקט,  בחירת דרך המימוש שלו ובחירת הרכיבים שצריך להזמין.   חשבנו על מספר דרכי מימוש,  ביררנו על כל דרך באינטרנט,  עד שהחלטנו על הדרך הטובה ביותר. </p>
			<p></p>
			<p>
                היינו אופטימים במחשבה שנוכל להוריד מ-github קוד אשר קורא נתונים מהרכיב hx711, "לשתול" אותו בתוכנית שלנו ולקוות שהוא יעבוד. כמובן שלא כך היה המצב, מהר מאוד הבנו שללא קריאה מעמיקה של הדוקומנטציה של הרכיב, לא נצליח לכתוב את המחלקה כך שהיא תעבוד כמו שצריך. הקוד אשר אחראי על קריאת הנתונים עבר מספר רב של גירסאות עד שהגענו  לגירסה הסופית שלו. הקושי עיקרי בכתיבת המחלקה היה בכיול המשקל שלקח לנו זמן להבין את מהותו ואת המתמטיקה שמאחוריו.
			</p>
            <p>
                חששנו מהשימוש ב socket programming לשם יצירת התקשורת בין האפליקציה לRPI. חשבנו בהתחלה ליצור את התקשורת דרך הענן, אולם לבסוף התברר לנו שמדובר בעבודה קשה שמהווה מתכון לתקלות בזמן ששימוש בsockets הוא פשוט יותר ואמין יותר. החלטנו להשתמש בענן למטרות של אחסון מידע בלבד, ולא למטרת העברת הודעות בין מכשירים.
            </p>
            <p>
                היו הרבה בעיות של התקנת כל הספריות של azure ו xamarin  ב visual studio.  הבעיות נבעו משינויים בגרסאות השונות והתנגשות של ספריות.  לאחר שיטוט באינטרנט וניסוי של מספר פתרונות הכוללים מחיקת גרסאות מסוימות של ספריות ושל visual studio,  הצלחנו להתגבר על בעייה זו.
            </p>
			<p>
				בעייה נוספת הייתה בבאגים שהיו קיימים בספריות של מייקרוסופט בצד השרת הכתוב בשפת C#.  הייתה בעייה מפורסמת שלא היה ניתן להוסיף טבלה חדשה לבסיס הנתונים SQL,  (זה נקרא Table Controller).  לאחר שיטוט ממושך באינטרנט, התברר כי זו בעייה ידועה והיו הרבה הצעות לפתרונות שלא עבדו.  שלחתי (רון) שאלה בפורום של מייקרוסופט ושם נאמר לי על ידי עובדי מייקרוסופט שזו בעייה בגרסה החדשה של visual studio,  והמליצו לי להתקין גרסא ניסיונית חדשה (VS 2017 Preview).  גם פתרון זה לא עבד.   לבסוף, החלטתי לממש את צד השרת בשפת Node.Js,  ושם הבעייה לא הייתה קיימת.  הוספת טבלה חדשה מתבצעת בקלות על ידי Easy Tables בפורטל של Azure. 
			</p>
			<p>
				התחבטנו רבות בשאלה כיצד תיראה התקשורת בין האפליקציה ל-RPI וכיצד ניתן לזהותם. אחד הפתרונות הראשונים שניסינו לממש היה זיהוי באמצעות כתובות MAC. לצורך כך המצאנו את פרוטוקול ה-MEP, או MAC Exchange Protocol, אביו ההיסטורי של ה-DRP. ה-MEP היווה את הפורמט בו האפליקציה וה-RPI שלחו הודעות אחד לשני על מנת לשתף זה עם זה את כתובות ה-MAC וה-IP שלהם. על פי הרעיון הזה, האפליקציה היתה אמורה לסרוק את רשת ה-wifi אליה היא מחוברת, ולשלוח הודעת MEP לכל המכשירים בה. ה-RPI של המשקל עליו עולה המשתמש שולח הודעה בחזרה לאפליקציה, ומזה הרגע לשניהם יש את הפרטים זה של זה. לצורך כך בנינו מחלקות שרת ולקוח ל-MEP.
			</p>
			<p>
				הבעיות שנוצרו:
			</p>
			<ul>
				<li>על מנת להתחיל להשקל במקום חדש האפליקציה צריכה לסרוק מאגר של מכשירים באותה הרשת (מאגר שיכול להיות גדול במקומות ציבוריים), ולחפש אותם בטבלת SQL באז'ור- שתי פעולות יקרות מבחינת סבוכיות זמן.</li>
				<li>יכול להיות מצב שבו שני מכשירי Weight Track (או יותר) שנמצאים על אותה הרשת יענו לאפליקציה.</li>
			</ul>
			<p>
				הפתרון היה שימוש בסריקת קוד QR על מנת ליצור את הזיהוי, והחלפת פרוטוקול MEP בפרוטוקול DRP.
			</p>
			<h3>אתגרים בתחום החומרה</h3>
			<p>
				 מכיוון שאין לנו רקע בתחום, זו לנו ההתנסות הראשונה ברכיבי חומרה, חיישנים ו-RPI. משום כך עלו בפנינו קשיים בהרכבת החומרה עצמה.
			</p>
            <p>
                מכיוון שרכיבי החומרה הפרוייקט שלנו מחוברים זה לזה בכמעין "שרשרת" היינו צריכים לבדוק כל אחד מהם בנפרד לפני שיכולנו לחבר את כולם יחד.
            </p>
			<p>
                לשם כך השתמש ברכיב Load cell אשר מסוגל לשקול עד 1 ק"ג בלבד. היות ומדובר בסנסור בודד (במקום באיחוד של ארבעה סנוסורים) יכולנו לחבר אותו לרכיב ה-Amplifier ללא צורך בקומבינטור. לכן, בעזרתו יכולנו לכתוב אתה הקוד המתממשק לחומרה ולדבג אותו. ורק לאחר שווידאנו שהוא עובד על מד-המשקל הקטן חיברנו את ה- Amplifier למד המשקל שבו אנו משתמשים בפרוייקט.
			</p>
            <p>
                חיבור רכיב ה-Combinator היוו אף הוא אתגר לא קטן. בהתחלה ניסינו לבנות את הרכיב בעצמנו (משום שלא היה ניתן להשיג אותו אצל הספק שעובד עם אונ' תל אביב). נעזרנו <a href="https://cdn.sparkfun.com/datasheets/Sensors/ForceFlex/SparkFun%20Load%20Sensor%20Combinator%20v11.pdf">במדריך הזה</a> לשם כך. אולם לא הצלחנו לגרום לסנסור לעבוד ולבסוף העדפנו לקנות את הקומבינטור בעצמנו מספק אחר במקום לבנות אותו לבד.
            </p>
            <p>
                נעזרנו במנחה שלנו, סיוון טולדו, כדי לבצע את פעולות הלחמה של הרכיבים.
            </p>
		</section>
    </article>
</main>


</body></html>